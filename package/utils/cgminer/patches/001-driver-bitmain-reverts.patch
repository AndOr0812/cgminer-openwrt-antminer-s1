--- a/driver-bitmain.c	2014-07-29 02:22:04.157735201 +0000
+++ b/driver-bitmain.c	2014-07-29 02:22:16.625735146 +0000
@@ -13,44 +13,18 @@
 #include "miner.h"
 
 #ifndef LINUX
-
-#ifdef USE_ANT_S1
 static void ants1_detect(__maybe_unused bool hotplug)
 {
 }
-#endif
-#ifdef USE_ANT_S2
-static void ants2_detect(__maybe_unused bool hotplug)
-{
-}
-#endif
-
-#else // LINUX
+#else
 
 #include "elist.h"
 #include "usbutils.h"
 #include "driver-bitmain.h"
 #include "hexdump.c"
 #include "util.h"
-#include <fcntl.h>
-#include <unistd.h>
-#include <math.h>
-
-#ifdef USE_ANT_S1
-#define ANTDRV ants1_drv
-#else
-#define ANTDRV ants2_drv
-#endif
-
-#define BITMAIN_CALC_DIFF1	1
 
 bool opt_bitmain_hwerror = false;
-#ifdef USE_ANT_S2
-bool opt_bitmain_checkall = false;
-bool opt_bitmain_checkn2diff = false;
-bool opt_bitmain_beeper = false;
-bool opt_bitmain_tempoverctrl = true;
-#endif
 int opt_bitmain_temp = BITMAIN_TEMP_TARGET;
 int opt_bitmain_overheat = BITMAIN_TEMP_OVERHEAT;
 int opt_bitmain_fan_min = BITMAIN_DEFAULT_FAN_MIN_PWM;
@@ -59,11 +33,8 @@ int opt_bitmain_freq_min = BITMAIN_MIN_F
 int opt_bitmain_freq_max = BITMAIN_MAX_FREQUENCY;
 bool opt_bitmain_auto;
 
-static bool is_usb;
-
 static int option_offset = -1;
 
-#ifdef USE_ANT_S1
 static unsigned char bit_swap_table[256] =
 {
   0x00, 0x80, 0x40, 0xc0, 0x20, 0xa0, 0x60, 0xe0,
@@ -99,10 +70,8 @@ static unsigned char bit_swap_table[256]
   0x0f, 0x8f, 0x4f, 0xcf, 0x2f, 0xaf, 0x6f, 0xef,
   0x1f, 0x9f, 0x5f, 0xdf, 0x3f, 0xbf, 0x7f, 0xff,
 };
+
 #define bitswap(x) (bit_swap_table[x])
-#else
-#define bitswap(x) (x)
-#endif
 
 // --------------------------------------------------------------
 //      CRC16 check table
@@ -318,40 +287,25 @@ static bool get_options(int this_option_
 	return true;
 }
 
-#ifdef USE_ANT_S1
 static int bitmain_set_txconfig(struct bitmain_txconfig_token *bm,
-				uint8_t reset, uint8_t fan_eft, uint8_t timeout_eft, uint8_t frequency_eft,
-				uint8_t voltage_eft, uint8_t chain_check_time_eft, uint8_t chip_config_eft,
-				uint8_t hw_error_eft, uint8_t chain_num, uint8_t asic_num,
-				uint8_t fan_pwm_data, uint8_t timeout_data,
-				uint16_t frequency, uint8_t voltage, uint8_t chain_check_time,
-				uint8_t chip_address, uint8_t reg_address, uint8_t * reg_data)
-#else
-static int bitmain_set_txconfig(struct bitmain_txconfig_token *bm,
-				uint8_t reset, uint8_t fan_eft, uint8_t timeout_eft, uint8_t frequency_eft,
-				uint8_t voltage_eft, uint8_t chain_check_time_eft, uint8_t chip_config_eft,
-				uint8_t hw_error_eft, uint8_t beeper_ctrl, uint8_t temp_over_ctrl,
-				uint8_t chain_num, uint8_t asic_num,
-				uint8_t fan_pwm_data, uint8_t timeout_data,
-				uint16_t frequency, uint8_t voltage, uint8_t chain_check_time,
-				uint8_t chip_address, uint8_t reg_address, uint8_t * reg_data)
-#endif
+			    uint8_t reset, uint8_t fan_eft, uint8_t timeout_eft, uint8_t frequency_eft,
+			    uint8_t voltage_eft, uint8_t chain_check_time_eft, uint8_t chip_config_eft, uint8_t hw_error_eft,
+			    uint8_t chain_num, uint8_t asic_num, uint8_t fan_pwm_data, uint8_t timeout_data,
+			    uint16_t frequency, uint8_t voltage, uint8_t chain_check_time,
+			    uint8_t chip_address, uint8_t reg_address, uint8_t * reg_data)
 {
 	uint16_t crc = 0;
 	int datalen = 0;
-#ifdef USE_ANT_S2
-	uint8_t version = 0;
-#endif
 	uint8_t *sendbuf = (uint8_t *)bm;
 	if (unlikely(!bm)) {
-		applog(LOG_WARNING, "%s: %s() bm is null", ANTDRV.dname, __func__);
+		applog(LOG_WARNING, "%s: %s() bm is null", ants1_drv.dname, __func__);
 		return -1;
 	}
 
 	if (unlikely(timeout_data <= 0 || asic_num <= 0 || chain_num <= 0)) {
 		applog(LOG_WARNING, "%s: %s() parameter invalid"
 				    " timeout_data(%d) asic_num(%d) chain_num(%d)",
-				    ANTDRV.dname, __func__,
+				    ants1_drv.dname, __func__,
 				    (int)timeout_data, (int)asic_num, (int)chain_num);
 		return -1;
 	}
@@ -360,13 +314,7 @@ static int bitmain_set_txconfig(struct b
 	memset(bm, 0, datalen);
 
 	bm->token_type = BITMAIN_TOKEN_TYPE_TXCONFIG;
-#ifdef USE_ANT_S1
 	bm->length = datalen-2;
-#else
-	bm->version = version;
-	bm->length = datalen-4;
-	bm->length = htole16(bm->length);
-#endif
 	bm->reset = reset;
 	bm->fan_eft = fan_eft;
 	bm->timeout_eft = timeout_eft;
@@ -376,15 +324,7 @@ static int bitmain_set_txconfig(struct b
 	bm->chip_config_eft = chip_config_eft;
 	bm->hw_error_eft = hw_error_eft;
 
-#ifdef USE_ANT_S1
 	sendbuf[2] = bitswap(sendbuf[2]);
-#else
-	bm->beeper_ctrl = beeper_ctrl;
-	bm->temp_over_ctrl = temp_over_ctrl;
-
-	sendbuf[4] = bitswap(sendbuf[4]);
-	sendbuf[5] = bitswap(sendbuf[5]);
-#endif
 
 	bm->chain_num = chain_num;
 	bm->asic_num = asic_num;
@@ -402,35 +342,18 @@ static int bitmain_set_txconfig(struct b
 	crc = CRC16((uint8_t *)bm, datalen-2);
 	bm->crc = htole16(crc);
 
-#ifdef USE_ANT_S1
-	applogsiz(LOG_DEBUG, 512, "%s: %s() reset(%d) faneft(%d) touteft(%d) freqeft(%d)"
+	applog(LOG_DEBUG, "%s: %s() reset(%d) faneft(%d) touteft(%d) freqeft(%d)"
 			" volteft(%d) chainceft(%d) chipceft(%d) hweft(%d) mnum(%d)"
 			" anum(%d) fanpwmdata(%d) toutdata(%d) freq(%d) volt(%d)"
 			" chainctime(%d) regdata(%02x%02x%02x%02x) chipaddr(%02x)"
 			" regaddr(%02x) crc(%04x)",
-			ANTDRV.dname, __func__,
+			ants1_drv.dname, __func__,
 			(int)reset, (int)fan_eft, (int)timeout_eft, (int)frequency_eft,
 			(int)voltage_eft, (int)chain_check_time_eft, (int)chip_config_eft,
 			(int)hw_error_eft, (int)chain_num, (int)asic_num, (int)fan_pwm_data,
 			(int)timeout_data, (int)frequency, (int)voltage, (int)chain_check_time,
 			(int)reg_data[0], (int)reg_data[1], (int)reg_data[2], (int)reg_data[3],
 			(int)chip_address, (int)reg_address, (int)crc);
-#else
-	applogsiz(LOG_DEBUG, 512, "%s: %s() v(%d) reset(%d) faneft(%d) touteft(%d) freqeft(%d)"
-			" volteft(%d) chainceft(%d) chipceft(%d) hweft(%d)"
-			" beepctrl(%d) toverctl(%d) mnum(%d)"
-			" anum(%d) fanpwmdata(%d) toutdata(%d) freq(%d) volt(%d)"
-			" chainctime(%d) regdata(%02x%02x%02x%02x) chipaddr(%02x)"
-			" regaddr(%02x) crc(%04x)",
-			ANTDRV.dname, __func__,
-			(int)version, (int)reset, (int)fan_eft, (int)timeout_eft,
-			(int)frequency_eft, (int)voltage_eft, (int)chain_check_time_eft,
-			(int)chip_config_eft, (int)hw_error_eft, (int)beeper_ctrl,
-			(int)temp_over_ctrl, (int)chain_num, (int)asic_num, (int)fan_pwm_data,
-			(int)timeout_data, (int)frequency, (int)voltage, (int)chain_check_time,
-			(int)reg_data[0], (int)reg_data[1], (int)reg_data[2], (int)reg_data[3],
-			(int)chip_address, (int)reg_address, (int)crc);
-#endif
 
 	return datalen;
 }
@@ -445,82 +368,61 @@ static int bitmain_set_txtask(struct bit
 	//char *ob_hex = NULL;
 	struct bitmain_txtask_token *bm = (struct bitmain_txtask_token *)sendbuf;
 	int cursentcount = 0;
-#ifdef USE_ANT_S2
-	uint8_t version = 0;
-	int diffbits, lowestdiffbits = -1;
-	double workdiff;
-#endif
 	K_ITEM *witem;
 
 	*sentcount = 0;
 
 	if (unlikely(!bm)) {
-		applog(LOG_WARNING, "%s: %s() bm is null", ANTDRV.dname, __func__);
+		applog(LOG_WARNING, "%s: %s() bm is null", ants1_drv.dname, __func__);
 		return -1;
 	}
 	memset(bm, 0, sizeof(struct bitmain_txtask_token));
 
 	bm->token_type = BITMAIN_TOKEN_TYPE_TXTASK;
-#ifdef USE_ANT_S2
-	bm->version = version;
-	if (info->wbuild->head)
-		quithere(1, "%s: %s() wbuild wasn't empty", ANTDRV.dname, __func__);
-#endif
 
 	datalen = 10;
-	applog(LOG_DEBUG, "%s: send work count %d", ANTDRV.dname, info->work_ready->count);
+	applog(LOG_DEBUG, "%s: send work count %d", ants1_drv.dname, info->work_ready->count);
 	while (info->work_ready->count) {
-		witem = k_unlink_tail(info->work_ready);
+		witem = k_unlink_head(info->work_ready);
 		if (DATAW(witem)->work->work_block > *last_work_block) {
 			applog(LOG_ERR, "%s: send task new block %d old(%d)",
-					ANTDRV.dname,
+					ants1_drv.dname,
 					DATAW(witem)->work->work_block, *last_work_block);
 			new_block = 1;
 			*last_work_block = DATAW(witem)->work->work_block;
 		}
-		work_id = DATAW(witem)->wid;
+#ifdef BITMAIN_TEST
+		if (!hex2bin(DATAW(witem)->work->data, btm_work_test_data, 128)) {
+			applog(LOG_DEBUG, "%s: send task set test data error",
+					  ants1_drv.dname);
+		}
+
+		if (!hex2bin(DATAW(witem)->work->midstate, btm_work_test_midstate, 32)) {
+			applog(LOG_DEBUG, "%s: send task set test midstate error",
+					  ants1_drv.dname);
+		}
+#endif
+		work_id = DATAW(witem)->work->id;
 		bm->works[cursentcount].work_id = htole32(work_id);
 		applog(LOG_DEBUG, "%s: send task work id:%"PRIu32" %"PRIu32,
-				  ANTDRV.dname,
+				  ants1_drv.dname,
 				  bm->works[cursentcount].work_id, work_id);
 		memcpy(bm->works[cursentcount].midstate, DATAW(witem)->work->midstate, 32);
 		memcpy(bm->works[cursentcount].data2, DATAW(witem)->work->data + 64, 12);
 
-		cursentcount++;
+		/*ob_hex = bin2hex(DATAW(witem)->work->data, 76);
+		applog(LOG_ERR, "%s: work %d data: %s",
+				ants1_drv.dname,
+				DATAW(witem)->work->id, ob_hex);
+		free(ob_hex);*/
 
-#ifdef USE_ANT_S1
+		cursentcount++;
 		k_add_head(info->work_list, witem);
-#else
-		k_add_head(info->wbuild, witem);
-
-		diffbits = (int)floor(log2(DATAW(witem)->work->sdiff));
-		if (diffbits < 0)
-			diffbits = 0;
-		// Limit to 4096 so solo mining has reasonable mining stats
-		if (diffbits > 12)
-			diffbits = 12;
-
-		// Must use diffbits <= all work being sent
-		if (lowestdiffbits == -1 || lowestdiffbits > diffbits)
-			lowestdiffbits = diffbits;
-#endif
-
 	}
 	if (cursentcount <= 0) {
-		applog(LOG_ERR, "%s: send work count %d", ANTDRV.dname, cursentcount);
+		applog(LOG_ERR, "%s: send work count %d", ants1_drv.dname, cursentcount);
 		return 0;
 	}
-
-#ifdef USE_ANT_S2
-	workdiff = pow(2.0, (double)lowestdiffbits);
-	witem = info->wbuild->head;
-	while (witem) {
-		DATAW(witem)->work->device_diff = workdiff;
-		witem = witem->next;
-	}
-	k_list_transfer_to_head(info->wbuild, info->work_list);
-#endif
-
 	datalen += 48*cursentcount;
 
 	bm->length = datalen-4;
@@ -529,14 +431,11 @@ static int bitmain_set_txtask(struct bit
 	//len = htole16(len);
 	//memcpy(sendbuf+1, &len, 2);
 	bm->new_block = new_block;
-#ifdef USE_ANT_S2
-	bm->diff = lowestdiffbits;
-#endif
 
 	sendbuf[4] = bitswap(sendbuf[4]);
 
 	applog(LOG_DEBUG, "%s: TxTask Token: %d %d %02x%02x%02x%02x%02x%02x",
-			  ANTDRV.dname,
+			  ants1_drv.dname,
 			  datalen, bm->length,
 			  sendbuf[0], sendbuf[1], sendbuf[2],
 			  sendbuf[3], sendbuf[4], sendbuf[5]);
@@ -547,20 +446,11 @@ static int bitmain_set_txtask(struct bit
 	crc = htole16(crc);
 	memcpy(sendbuf+datalen-2, &crc, 2);
 
-#ifdef USE_ANT_S1
-	applog(LOG_DEBUG, "%s: TxTask Token: new_block(%d) work_num(%d)"
-			  " crc(%04x)",
-			  ANTDRV.dname,
-			  (int)new_block, cursentcount, (int)crc);
-#else
-	applog(LOG_DEBUG, "%s: TxTask Token: v(%d) new_block(%d)"
-			  " diff(%d work:%f) work_num(%d) crc(%04x)",
-			  ANTDRV.dname,
-			  (int)version, (int)new_block, lowestdiffbits, workdiff,
-			  cursentcount, (int)crc);
-#endif
+	applog(LOG_DEBUG, "%s: TxTask Token: new_block(%d) work_num(%d) crc(%04x)",
+			  ants1_drv.dname,
+			  new_block, cursentcount, crc);
 	applog(LOG_DEBUG, "%s: TxTask Token: %d %d %02x%02x%02x%02x%02x%02x",
-			  ANTDRV.dname,
+			  ants1_drv.dname,
 			  datalen, bm->length,
 			  sendbuf[0], sendbuf[1], sendbuf[2],
 			  sendbuf[3], sendbuf[4], sendbuf[5]);
@@ -574,12 +464,9 @@ static int bitmain_set_rxstatus(struct b
 	uint16_t crc = 0;
 	int datalen = 0;
 	uint8_t *sendbuf = (uint8_t *)bm;
-#ifdef USE_ANT_S2
-	uint8_t version = 0;
-#endif
 
 	if (unlikely(!bm)) {
-		applog(LOG_WARNING, "%s: %s() bm is null", ANTDRV.dname, __func__);
+		applog(LOG_WARNING, "%s: %s() bm is null", ants1_drv.dname, __func__);
 		return -1;
 	}
 
@@ -587,22 +474,12 @@ static int bitmain_set_rxstatus(struct b
 	memset(bm, 0, datalen);
 
 	bm->token_type = BITMAIN_TOKEN_TYPE_RXSTATUS;
-#ifdef USE_ANT_S1
 	bm->length = datalen-2;
-#else
-	bm->version = version;
-	bm->length = datalen-4;
-	bm->length = htole16(bm->length);
-#endif
 
 	bm->chip_status_eft = chip_status_eft;
 	bm->detect_get = detect_get;
 
-#ifdef USE_ANT_S1
 	sendbuf[2] = bitswap(sendbuf[2]);
-#else
-	sendbuf[4] = bitswap(sendbuf[4]);
-#endif
 
 	bm->chip_address = chip_address;
 	bm->reg_address = reg_address;
@@ -610,18 +487,10 @@ static int bitmain_set_rxstatus(struct b
 	crc = CRC16((uint8_t *)bm, datalen-2);
 	bm->crc = htole16(crc);
 
-#ifdef USE_ANT_S1
 	applog(LOG_DEBUG, "%s: RxStatus Token: chip_status_eft(%d) detect_get(%d)"
 			  " chip_address(%02x) reg_address(%02x) crc(%04x)",
-			  ANTDRV.dname,
-			  (int)chip_status_eft, (int)detect_get, chip_address, reg_address, crc);
-#else
-	applog(LOG_DEBUG, "%s: RxStatus Token: v(%d) chip_status_eft(%d) detect_get(%d)"
-			  " chip_address(%02x) reg_address(%02x) crc(%04x)",
-			  ANTDRV.dname,
-			  (int)version, (int)chip_status_eft, (int)detect_get,
-			  chip_address, reg_address, crc);
-#endif
+			  ants1_drv.dname,
+			  chip_status_eft, detect_get, chip_address, reg_address, crc);
 
 	return datalen;
 }
@@ -630,36 +499,27 @@ static int bitmain_parse_rxstatus(const
 {
 	uint16_t crc = 0;
 	int i = 0;
-#ifdef USE_ANT_S2
-	uint8_t version = 0;
-	int j = 0;
-	int asic_num = 0;
-	int dataindex = 0;
-#endif
-
 	if (unlikely(!bm)) {
-		applog(LOG_ERR, "%s: %s() bm is null", ANTDRV.dname, __func__);
+		applog(LOG_ERR, "%s: %s() bm is null", ants1_drv.dname, __func__);
 		return -1;
 	}
 	if (unlikely(!data || datalen <= 0)) {
 		applog(LOG_ERR, "%s: %s() parameter invalid data is null"
 				" or datalen(%d) error",
-				ANTDRV.dname, __func__, datalen);
+				ants1_drv.dname, __func__, datalen);
 		return -1;
 	}
-
-#ifdef USE_ANT_S1
 	memcpy(bm, data, sizeof(struct bitmain_rxstatus_data));
 	if (bm->data_type != BITMAIN_DATA_TYPE_RXSTATUS) {
 		applog(LOG_ERR, "%s: %s() datatype(%02x) error",
-				ANTDRV.dname, __func__,
+				ants1_drv.dname, __func__,
 				bm->data_type);
 		return -1;
 	}
 	if (bm->length+2 != datalen) {
-		applog(LOG_ERR, "%s: %s() length(%d) datalen(%d) error",
-				ANTDRV.dname, __func__,
-				bm->length, datalen);
+		applog(LOG_ERR, "%s: %s() length(%d) error",
+				ants1_drv.dname, __func__,
+				bm->length);
 		return -1;
 	}
 	crc = CRC16(data, datalen-2);
@@ -668,7 +528,7 @@ static int bitmain_parse_rxstatus(const
 	if (crc != bm->crc) {
 		applog(LOG_ERR, "%s: %s() check crc(%d)"
 				" != bm crc(%d) datalen(%d)",
-				ANTDRV.dname, __func__,
+				ants1_drv.dname, __func__,
 				crc, bm->crc, datalen);
 		return -1;
 	}
@@ -677,13 +537,13 @@ static int bitmain_parse_rxstatus(const
 	if (bm->chain_num*5 + bm->temp_num + bm->fan_num + 22 != datalen) {
 		applog(LOG_ERR, "%s: %s() chain_num(%d) temp_num(%d)"
 				" fan_num(%d) not match datalen(%d)",
-				ANTDRV.dname, __func__,
+				ants1_drv.dname, __func__,
 				bm->chain_num, bm->temp_num, bm->fan_num, datalen);
 		return -1;
 	}
 	if (bm->chain_num > BITMAIN_MAX_CHAIN_NUM) {
 		applog(LOG_ERR, "%s: %s() chain_num=%d error",
-				ANTDRV.dname, __func__,
+				ants1_drv.dname, __func__,
 				bm->chain_num);
 		return -1;
 	}
@@ -691,147 +551,37 @@ static int bitmain_parse_rxstatus(const
 		memcpy(bm->chain_asic_status, data+20, bm->chain_num*4);
 		memcpy(bm->chain_asic_num, data+20+bm->chain_num*4, bm->chain_num);
 	}
-	for (i = 0; i < bm->chain_num; i++)
+	for (i = 0; i < bm->chain_num; i++) {
+		//bm->chain_asic_status[i] = swab32(bm->chain_asic_status[i]);
 		bm->chain_asic_status[i] = htole32(bm->chain_asic_status[i]);
-	if (bm->temp_num > 0)
+	}
+	if (bm->temp_num > 0) {
 		memcpy(bm->temp, data+20+bm->chain_num*5, bm->temp_num);
-	if (bm->fan_num > 0)
+	}
+	if (bm->fan_num > 0) {
 		memcpy(bm->fan, data+20+bm->chain_num*5+bm->temp_num, bm->fan_num);
+	}
 	applog(LOG_DEBUG, "%s: RxStatus Data chipvalueeft(%d) version(%d) fifospace(%d)"
 			  " regvalue(%d) chainnum(%d) tempnum(%d) fannum(%d) crc(%04x)",
-			  ANTDRV.dname,
+			  ants1_drv.dname,
 			  bm->chip_value_eft, bm->version, bm->fifo_space, bm->reg_value,
 			  bm->chain_num, bm->temp_num, bm->fan_num, bm->crc);
-	applog(LOG_DEBUG, "%s: RxStatus Data chain info:", ANTDRV.dname);
+	applog(LOG_DEBUG, "%s: RxStatus Data chain info:", ants1_drv.dname);
 	for (i = 0; i < bm->chain_num; i++) {
 		applog(LOG_DEBUG, "%s: RxStatus Data chain(%d) asic num=%d asic_status=%08x",
-				  ANTDRV.dname,
+				  ants1_drv.dname,
 				  i+1, bm->chain_asic_num[i], bm->chain_asic_status[i]);
 	}
-#else // USE_ANT_S2
-	memset(bm, 0, sizeof(struct bitmain_rxstatus_data));
-	memcpy(bm, data, 28);
-	if (bm->data_type != BITMAIN_DATA_TYPE_RXSTATUS) {
-		applog(LOG_ERR, "%s: %s() datatype(%02x) error",
-				ANTDRV.dname, __func__,
-				bm->data_type);
-		return -1;
-	}
-	if (bm->version != version) {
-		applog(LOG_ERR, "%s: %s() version(%02x) error",
-				ANTDRV.dname, __func__,
-				bm->version);
-		return -1;
-	}
-	bm->length = htole16(bm->length);
-	if (bm->length+4 != datalen) {
-		applog(LOG_ERR, "%s: %s() length(%d) datalen(%d) error",
-				ANTDRV.dname, __func__,
-				bm->length, datalen);
-		return -1;
-	}
-	crc = CRC16(data, datalen-2);
-	memcpy(&(bm->crc), data+datalen-2, 2);
-	bm->crc = htole16(bm->crc);
-	if (crc != bm->crc) {
-		applog(LOG_ERR, "%s: %s() check crc(%d)"
-				" != bm crc(%d) datalen(%d)",
-				ANTDRV.dname, __func__,
-				crc, bm->crc, datalen);
-		return -1;
-	}
-	bm->fifo_space = htole16(bm->fifo_space);
-	bm->fan_exist = htole16(bm->fan_exist);
-	bm->temp_exist = htole32(bm->temp_exist);
-	bm->nonce_error = htole32(bm->nonce_error);
-	if (bm->chain_num > BITMAIN_MAX_CHAIN_NUM) {
-		applog(LOG_ERR, "%s: %s() chain_num=%d error",
-				ANTDRV.dname, __func__,
-				bm->chain_num);
-		return -1;
-	}
-	dataindex = 28;
-	if (bm->chain_num > 0) {
-		memcpy(bm->chain_asic_num,
-			data+datalen-2-bm->chain_num-bm->temp_num-bm->fan_num,
-			bm->chain_num);
-	}
-	for (i = 0; i < bm->chain_num; i++) {
-		asic_num = bm->chain_asic_num[i];
-		if (asic_num < 0)
-			asic_num = 0;
-		else {
-			if (asic_num % 32 == 0)
-				asic_num = asic_num / 32;
-			else
-				asic_num = asic_num / 32 + 1;
-		}
-		memcpy((uint8_t *)bm->chain_asic_exist+i*32, data+dataindex, asic_num*4);
-		dataindex += asic_num*4;
-	}
-	for(i = 0; i < bm->chain_num; i++) {
-		asic_num = bm->chain_asic_num[i];
-		if (asic_num < 0)
-			asic_num = 0;
-		else {
-			if (asic_num % 32 == 0)
-				asic_num = asic_num / 32;
-			else
-				asic_num = asic_num / 32 + 1;
-		}
-		memcpy((uint8_t *)bm->chain_asic_status+i*32, data+dataindex, asic_num*4);
-		dataindex += asic_num*4;
-	}
-	dataindex += bm->chain_num;
-	if ((dataindex + bm->temp_num + bm->fan_num + 2) != datalen) {
-		applog(LOG_ERR, "%s: %s() dataindex(%d) chain_num(%d) temp_num(%d)"
-				" fan_num(%d) not match datalen(%d)",
-				ANTDRV.dname, __func__,
-				dataindex, bm->chain_num, bm->temp_num, bm->fan_num, datalen);
-		return -1;
-	}
-	for (i = 0; i < bm->chain_num; i++) {
-		for (j = 0; j < 8; j++) {
-			bm->chain_asic_exist[i*8+j] = htole32(bm->chain_asic_exist[i*8+j]);
-			bm->chain_asic_status[i*8+j] = htole32(bm->chain_asic_status[i*8+j]);
-		}
-	}
-	if (bm->temp_num > 0) {
-		memcpy(bm->temp, data+dataindex, bm->temp_num);
-		dataindex += bm->temp_num;
-	}
-	if (bm->fan_num > 0) {
-		memcpy(bm->fan, data+dataindex, bm->fan_num);
-		dataindex += bm->fan_num;
-	}
-	applog(LOG_DEBUG, "%s: RxStatus Data chipv_e(%d) chainnum(%d) fifos(%d)"
-			  " v1(%d) v2(%d) v3(%d) v4(%d) fann(%d) tempn(%d) fanet(%04x)"
-			  " tempet(%08x) ne(%d) regvalue(%d) crc(%04x)",
-			  ANTDRV.dname,
-			  bm->chip_value_eft, bm->chain_num, bm->fifo_space,
-			  bm->hw_version[0], bm->hw_version[1], bm->hw_version[2],
-			  bm->hw_version[3], bm->fan_num, bm->temp_num, bm->fan_exist,
-			  bm->temp_exist, bm->nonce_error, bm->reg_value, bm->crc);
-	applog(LOG_DEBUG, "%s: RxStatus Data chain info:", ANTDRV.dname);
-	for (i = 0; i < bm->chain_num; i++) {
-		applog(LOG_DEBUG, "%s: RxStatus Data chain(%d) asic num=%d asic_exists=%08x"
-				  " asic_status=%08x",
-				  ANTDRV.dname,
-				  i+1, bm->chain_asic_num[i], bm->chain_asic_exist[i*8],
-				  bm->chain_asic_status[i*8]);
-	}
-#endif
-
-	applog(LOG_DEBUG, "%s: RxStatus Data temp info:", ANTDRV.dname);
+	applog(LOG_DEBUG, "%s: RxStatus Data temp info:", ants1_drv.dname);
 	for (i = 0; i < bm->temp_num; i++) {
 		applog(LOG_DEBUG, "%s: RxStatus Data temp(%d) temp=%d",
-				  ANTDRV.dname,
+				  ants1_drv.dname,
 				  i+1, bm->temp[i]);
 	}
-	applog(LOG_DEBUG, "%s: RxStatus Data fan info:", ANTDRV.dname);
+	applog(LOG_DEBUG, "%s: RxStatus Data fan info:", ants1_drv.dname);
 	for (i = 0; i < bm->fan_num; i++) {
 		applog(LOG_DEBUG, "%s: RxStatus Data fan(%d) fan=%d",
-				  ANTDRV.dname,
+				  ants1_drv.dname,
 				  i+1, bm->fan[i]);
 	}
 	return 0;
@@ -841,76 +591,51 @@ static int bitmain_parse_rxnonce(const u
 {
 	int i = 0;
 	uint16_t crc = 0;
-#ifdef USE_ANT_S2
-	uint8_t version = 0;
-#endif
 	int curnoncenum = 0;
 	if (unlikely(!bm)) {
-		applog(LOG_ERR, "%s: %s() bm is null", ANTDRV.dname, __func__);
+		applog(LOG_ERR, "%s: %s() bm is null", ants1_drv.dname, __func__);
 		return -1;
 	}
 	if (unlikely(!data || datalen <= 0)) {
 		applog(LOG_ERR, "%s: %s() parameter invalid data is null"
 				" or datalen(%d) error",
-				ANTDRV.dname, __func__, datalen);
+				ants1_drv.dname, __func__, datalen);
 		return -1;
 	}
 	memcpy(bm, data, sizeof(struct bitmain_rxnonce_data));
 
 	if (bm->data_type != BITMAIN_DATA_TYPE_RXNONCE) {
 		applog(LOG_ERR, "%s: %s() datatype(%02x) error",
-				ANTDRV.dname, __func__,
+				ants1_drv.dname, __func__,
 				bm->data_type);
 		return -1;
 	}
-#ifdef USE_ANT_S1
 	if (bm->length+2 != datalen) {
 		applog(LOG_ERR, "%s: %s() length(%d) error",
-				ANTDRV.dname, __func__,
+				ants1_drv.dname, __func__,
 				bm->length);
 		return -1;
 	}
-#else
-	if (bm->version != version) {
-		applog(LOG_ERR, "%s: %s() version(%02x) error",
-				ANTDRV.dname, __func__,
-				bm->version);
-		return -1;
-	}
-	bm->length = htole16(bm->length);
-	if (bm->length+4 != datalen) {
-		applog(LOG_ERR, "%s: %s() length(%d) datalen(%d) error",
-				ANTDRV.dname, __func__,
-				bm->length, datalen);
-		return -1;
-	}
-#endif
 	crc = CRC16(data, datalen-2);
 	memcpy(&(bm->crc), data+datalen-2, 2);
 	bm->crc = htole16(bm->crc);
 	if (crc != bm->crc) {
 		applog(LOG_ERR, "%s: %s() check crc(%d)"
 				" != bm crc(%d) datalen(%d)",
-				ANTDRV.dname, __func__,
+				ants1_drv.dname, __func__,
 				crc, bm->crc, datalen);
 		return -1;
 	}
-#ifdef USE_ANT_S1
 	curnoncenum = (datalen-4)/8;
-#else
-	bm->fifo_space = htole16(bm->fifo_space);
-	bm->diff = htole16(bm->diff);
-	bm->total_nonce_num = htole64(bm->total_nonce_num);
-	curnoncenum = (datalen-14)/8;
-#endif
-	applog(LOG_DEBUG, "%s: RxNonce Data: nonce_num(%d) fifo_space(%d)",
-			  ANTDRV.dname, curnoncenum, bm->fifo_space);
+	applog(LOG_DEBUG, "%s: RxNonce Data: nonce_num(%d-%d) fifo_space(%d)",
+			  ants1_drv.dname,
+			  curnoncenum, bm->nonce_num, bm->fifo_space);
 	for (i = 0; i < curnoncenum; i++) {
 		bm->nonces[i].work_id = htole32(bm->nonces[i].work_id);
 		bm->nonces[i].nonce = htole32(bm->nonces[i].nonce);
 
 		applog(LOG_DEBUG, "%s: RxNonce Data %d: work_id(%"PRIu32") nonce(%08x)(%d)",
-				  ANTDRV.dname,
+				  ants1_drv.dname,
 				  i, bm->nonces[i].work_id,
 				  bm->nonces[i].nonce, bm->nonces[i].nonce);
 	}
@@ -921,7 +646,6 @@ static int bitmain_parse_rxnonce(const u
 static int bitmain_read(struct cgpu_info *bitmain, unsigned char *buf,
 		       size_t bufsize, int timeout, int ep)
 {
-	__maybe_unused struct bitmain_info *info = bitmain->device_data;
 	int readlen = 0, err = 0;
 
 	if (bitmain == NULL || buf == NULL || bufsize <= 0) {
@@ -931,57 +655,35 @@ static int bitmain_read(struct cgpu_info
 		return -1;
 	}
 
-	if (is_usb) {
-		err = usb_read_once_timeout(bitmain, (char *)buf, bufsize, &readlen, timeout, ep);
-		applog(LOG_DEBUG, "%s%i: Get %s() got readlen %d err %d",
-				  bitmain->drv->name, bitmain->device_id,
-				  __func__, readlen, err);
-	}
-#ifdef USE_ANT_S2
-	else
-		readlen = read(info->device_fd, buf, bufsize);
-#endif
+	err = usb_read_once_timeout(bitmain, (char *)buf, bufsize, &readlen, timeout, ep);
+	applog(LOG_DEBUG, "%s%i: Get %s() got readlen %d err %d",
+			  bitmain->drv->name, bitmain->device_id,
+			  __func__, readlen, err);
+
 	return readlen;
 }
 
 static int bitmain_write(struct cgpu_info *bitmain, char *buf, ssize_t len, int ep)
 {
-	__maybe_unused struct bitmain_info *info = bitmain->device_data;
-	int err, amount, __maybe_unused sent;
+	int err, amount;
 
-	if (is_usb) {
-		err = usb_write(bitmain, buf, len, &amount, ep);
-		applog(LOG_DEBUG, "%s%d: usb_write got err %d",
-				  bitmain->drv->name, bitmain->device_id, err);
-
-		if (unlikely(err != 0)) {
-			applog(LOG_ERR, "%s%d: usb_write error on %s() err=%d",
-					bitmain->drv->name, bitmain->device_id, __func__, err);
-			return BTM_SEND_ERROR;
-		}
-		if (amount != len) {
-			applog(LOG_ERR, "%s%d: usb_write length mismatch on %s() "
-					"amount=%d len=%d",
-					bitmain->drv->name, bitmain->device_id, __func__,
-					amount, (int)len);
-			return BTM_SEND_ERROR;
-		}
+	err = usb_write(bitmain, buf, len, &amount, ep);
+	applog(LOG_DEBUG, "%s%d: usb_write got err %d",
+			  bitmain->drv->name, bitmain->device_id, err);
+
+	if (unlikely(err != 0)) {
+		applog(LOG_ERR, "%s%d: usb_write error on %s() err=%d",
+				bitmain->drv->name, bitmain->device_id, __func__, err);
+		return BTM_SEND_ERROR;
+	}
+	if (amount != len) {
+		applog(LOG_ERR, "%s%d: usb_write length mismatch on %s() "
+				"amount=%d len=%d",
+				bitmain->drv->name, bitmain->device_id, __func__,
+				amount, (int)len);
+		return BTM_SEND_ERROR;
 	}
-#ifdef USE_ANT_S2
-	else {
-		sent = 0;
 
-		while (sent < len) {
-			amount = write(info->device_fd, buf+sent, len-sent);
-			if (amount < 0) {
-				applog(LOG_WARNING, "%s%d: ser_write got err %d",
-						    bitmain->drv->name, bitmain->device_id, amount);
-				return BTM_SEND_ERROR;
-			}
-			sent += amount;
-		}
-	}
-#endif
 	return BTM_SEND_OK;
 }
 
@@ -1010,15 +712,15 @@ static int bitmain_send_data(const uint8
 	//delay += 4000;
 
 	if (opt_debug) {
-		applog(LOG_DEBUG, "%s: Sent(%d):", ANTDRV.dname, datalen);
+		applog(LOG_DEBUG, "%s: Sent(%d):", ants1_drv.dname, datalen);
 		hexdump(data, datalen);
 	}
 
 	//cgsleep_prepare_r(&ts_start);
-	applog(LOG_DEBUG, "%s: %s() start", ANTDRV.dname, __func__);
+	applog(LOG_DEBUG, "%s: %s() start", ants1_drv.dname, __func__);
 	ret = bitmain_write(bitmain, (char *)data, datalen, ep);
 	applog(LOG_DEBUG, "%s: %s() stop ret=%d datalen=%d",
-			  ANTDRV.dname, __func__, ret, datalen);
+			  ants1_drv.dname, __func__, ret, datalen);
 	//cgsleep_us_r(&ts_start, delay);
 
 	//applog(LOG_DEBUG, "BitMain: Sent: Buffer delay: %dus", delay);
@@ -1042,13 +744,15 @@ static inline void record_temp_fan(struc
 	*temp_avg = 0.0;
 
 	info->fan_num = bm->fan_num;
-	for (i = 0; i < bm->fan_num; i++)
+	for (i = 0; i < bm->fan_num; i++) {
 		info->fan[i] = bm->fan[i] * BITMAIN_FAN_FACTOR;
+	}
 	info->temp_num = bm->temp_num;
 	info->temp_hi = 0;
 	for (i = 0; i < bm->temp_num; i++) {
 		info->temp[i] = bm->temp[i];
-		/* if (bm->temp[i] & 0x80) {
+		/*
+		if (bm->temp[i] & 0x80) {
 			bm->temp[i] &= 0x7f;
 			info->temp[i] = 0 - ((~bm->temp[i] & 0x7f) + 1);
 		}*/
@@ -1102,7 +806,6 @@ static void bitmain_update_temps(struct
 		info->temp_history_index = 0;
 		info->temp_sum = 0;
 	}
-#ifdef USE_ANT_S1
 	if (unlikely(info->temp_hi >= opt_bitmain_overheat)) {
 		if (!info->overheat) {
 			applog(LOG_WARNING, "%s%d: overheat! hi %dC limit %dC idling",
@@ -1119,13 +822,11 @@ static void bitmain_update_temps(struct
 		info->overheat = false;
 		info->overheat_recovers++;
 	}
-#endif
 }
 
 static void bitmain_parse_results(struct cgpu_info *bitmain, struct bitmain_info *info,
 				  struct thr_info *thr, uint8_t *buf, int *offset)
 {
-#ifdef USE_ANT_S1
 	int i, j, n, m, errordiff, spare = BITMAIN_READ_SIZE;
 	uint32_t checkbit = 0x00000000;
 	bool found = false;
@@ -1272,308 +973,41 @@ static void bitmain_parse_results(struct
 								  rxnoncedata.nonces[j].work_id,
 								  rxnoncedata.nonces[j].nonce);
 
-						applog(LOG_DEBUG, "%s%d: %s() nonce = %08x",
-								  bitmain->drv->name, bitmain->device_id,
-								  __func__, rxnoncedata.nonces[j].nonce);
-						if (isdupnonce(bitmain, work, rxnoncedata.nonces[j].nonce)) {
-							// ignore it
-						} else {
-							if (submit_nonce(thr, work, rxnoncedata.nonces[j].nonce)) {
-								applog(LOG_DEBUG, "%s%d: %s() RxNonce Data ok",
-										  bitmain->drv->name,
-										  bitmain->device_id,
-										  __func__);
-								mutex_lock(&info->qlock);
-								info->nonces++;
-								mutex_unlock(&info->qlock);
-							} else {
-								applog(LOG_ERR, "%s%d: %s() RxNonce Data "
-										"error work(%"PRIu32")",
-										bitmain->drv->name,
-										bitmain->device_id,
-										__func__,
-										rxnoncedata.nonces[j].work_id);
-							}
-						}
-					} else {
-						if (info->failed_search == 0) {
-							info->min_failed = searches;
-							info->max_failed = searches;
-						} else {
-							if (info->min_failed > searches)
-								info->min_failed = searches;
-							if (info->max_failed < searches)
-								info->max_failed = searches;
-						}
-						info->failed_search++;
-						info->tot_failed += searches;
-
-						mutex_lock(&info->qlock);
-						uint32_t min = 0, max = 0;
-						int count = 0;
-						if (info->work_list->tail) {
-							min = DATAW(info->work_list->tail)->wid;
-							max = DATAW(info->work_list->head)->wid;
-							count = info->work_list->count;
-						}
-						mutex_unlock(&info->qlock);
-						applog(LOG_ERR, "%s%d: %s() Work not found for id (%"PRIu32")"
-								" (min=%"PRIu32" max=%"PRIu32" count=%d)",
+						/*ob_hex = bin2hex(work->midstate, 32);
+						applog(LOG_ERR, "%s%d: work %d midstate: %s",
 								bitmain->drv->name, bitmain->device_id,
-								__func__, rxnoncedata.nonces[j].work_id,
-								min, max, count);
-					}
-				}
-				mutex_lock(&info->qlock);
-				info->fifo_space = rxnoncedata.fifo_space;
-				mutex_unlock(&info->qlock);
-				applog(LOG_DEBUG, "%s%d: %s() RxNonce Data fifo space=%d",
-						  bitmain->drv->name, bitmain->device_id,
-						  __func__, rxnoncedata.fifo_space);
-			}
-
-			found = true;
-			spare = buf[i+1] + 2 + i;
-			if (spare > *offset) {
-				applog(LOG_ERR, "%s%d: %s() RxNonce Data space(%d) > offset(%d)",
-						bitmain->drv->name, bitmain->device_id, __func__, 
-						spare, *offset);
-				spare = *offset;
-			}
-			break;
-		} else {
-			applog(LOG_ERR, "%s%d: %s() data type error=%02x",
-					bitmain->drv->name, bitmain->device_id,
-					__func__, buf[i]);
-		}
-	}
-	if (!found) {
-		spare = *offset - BITMAIN_READ_SIZE;
-		/* We are buffering and haven't accumulated one more corrupt
-		 * work result. */
-		if (spare < (int)BITMAIN_READ_SIZE)
-			return;
-		bitmain_inc_nvw(info, thr);
-	}
-
-	*offset -= spare;
-	memmove(buf, buf + spare, *offset);
-#else // S2
-	int i, j, n, m, r, errordiff, spare = BITMAIN_READ_SIZE;
-	uint32_t checkbit = 0x00000000;
-	bool found = false;
-	struct work *work = NULL;
-	struct bitmain_packet_head packethead;
-	int asicnum = 0;
-	uint64_t searches;
-	K_ITEM *witem;
-
-	for (i = 0; i <= spare; i++) {
-		if (buf[i] == 0xa1) {
-			struct bitmain_rxstatus_data rxstatusdata;
-			applog(LOG_DEBUG, "%s%d: %s() RxStatus Data",
-					  bitmain->drv->name, bitmain->device_id,
-					  __func__);
-			if (*offset < 4) {
-				return;
-			}
-			memcpy(&packethead, buf+i, sizeof(struct bitmain_packet_head));
-			packethead.length = htole16(packethead.length);
-			if (packethead.length > 1130) {
-				applog(LOG_ERR, "%s%d: %s() RxStatus Data datalen=%d error",
-						bitmain->drv->name, bitmain->device_id,
-						__func__, packethead.length+4);
-				continue;
-			}
-			if (*offset < packethead.length + 4)
-				return;
-			if (bitmain_parse_rxstatus(buf+i, packethead.length+4, &rxstatusdata) != 0) {
-				applog(LOG_ERR, "%s%d: %s() RxStatus Data error len=%d",
-						bitmain->drv->name, bitmain->device_id,
-						__func__, packethead.length+4);
-			} else {
-				mutex_lock(&info->qlock);
-				info->chain_num = rxstatusdata.chain_num;
-				info->fifo_space = rxstatusdata.fifo_space;
-				info->hw_version[0] = rxstatusdata.hw_version[0];
-				info->hw_version[1] = rxstatusdata.hw_version[1];
-				info->hw_version[2] = rxstatusdata.hw_version[2];
-				info->hw_version[3] = rxstatusdata.hw_version[3];
-				info->nonce_error = rxstatusdata.nonce_error;
-				errordiff = info->nonce_error-info->last_nonce_error;
-				applog(LOG_DEBUG, "%s%d: %s() RxStatus Data"
-						" version=%d chainnum=%d fifospace=%d"
-						" hwv1=%d hwv2=%d hwv3=%d hwv4=%d"
-						" nonceerror=%d-%d freq=%d chain info:",
-						bitmain->drv->name, bitmain->device_id, __func__,
-						rxstatusdata.version, info->chain_num, info->fifo_space,
-						info->hw_version[0], info->hw_version[1],
-						info->hw_version[2], info->hw_version[3],
-						info->last_nonce_error,
-						info->nonce_error, info->frequency);
-				memcpy(info->chain_asic_exist, rxstatusdata.chain_asic_exist, BITMAIN_MAX_CHAIN_NUM*32);
-				memcpy(info->chain_asic_status, rxstatusdata.chain_asic_status, BITMAIN_MAX_CHAIN_NUM*32);
-				for (n = 0; n < rxstatusdata.chain_num; n++) {
-					info->chain_asic_num[n] = rxstatusdata.chain_asic_num[n];
-					memset(info->chain_asic_status_t[n], 0, 320);
-					j = 0;
-					if (info->chain_asic_num[n] <= 0)
-						asicnum = 0;
-					else {
-						if (info->chain_asic_num[n] % 32 == 0)
-							asicnum = info->chain_asic_num[n] / 32;
-						else
-							asicnum = info->chain_asic_num[n] / 32 + 1;
-					}
-					if (asicnum > 0) {
-						for (m = asicnum-1; m >= 0; m--) {
-							for (r = 0; r < 32; r++) {
-								if ((r % 8) == 0 && r != 0) {
-									info->chain_asic_status_t[n][j] = ' ';
-									j++;
-								}
-								checkbit = num2bit(r);
-								if (rxstatusdata.chain_asic_exist[n*8+m] & checkbit) {
-									if (rxstatusdata.chain_asic_status[n*8+m] & checkbit)
-										info->chain_asic_status_t[n][j] = 'o';
-									else
-										info->chain_asic_status_t[n][j] = 'x';
-								} else
-									info->chain_asic_status_t[n][j] = '-';
-								j++;
-							}
-							info->chain_asic_status_t[n][j] = ' ';
-							j++;
-						}
-					}
-					applog(LOG_DEBUG, "%s%d: %s() RxStatis Data chain(%d) asic_num=%d "
-							  "asic_exist=%08x%08x%08x%08x%08x%08x%08x%08x "
-							  "asic_status=%08x%08x%08x%08x%08x%08x%08x%08x",
-							  bitmain->drv->name, bitmain->device_id,
-							  __func__, n, info->chain_asic_num[n],
-							  info->chain_asic_exist[n*8+0],
-							  info->chain_asic_exist[n*8+1],
-							  info->chain_asic_exist[n*8+2],
-							  info->chain_asic_exist[n*8+3],
-							  info->chain_asic_exist[n*8+4],
-							  info->chain_asic_exist[n*8+5],
-							  info->chain_asic_exist[n*8+6],
-							  info->chain_asic_exist[n*8+7],
-							  info->chain_asic_status[n*8+0],
-							  info->chain_asic_status[n*8+1],
-							  info->chain_asic_status[n*8+2],
-							  info->chain_asic_status[n*8+3],
-							  info->chain_asic_status[n*8+4],
-							  info->chain_asic_status[n*8+5],
-							  info->chain_asic_status[n*8+6],
-							  info->chain_asic_status[n*8+7]);
-					applog(LOG_ERR, "%s%d: %s() RxStatis Data chain(%d) asic_num=%d"
-							" asic_status=%s",
-							bitmain->drv->name, bitmain->device_id,
-							__func__, n, info->chain_asic_num[n],
-							info->chain_asic_status_t[n]);
-				}
-				mutex_unlock(&info->qlock);
-
-				if (errordiff > 0) {
-					for (j = 0; j < errordiff; j++)
-						bitmain_inc_nvw(info, thr);
-					mutex_lock(&info->qlock);
-					info->last_nonce_error += errordiff;
-					mutex_unlock(&info->qlock);
-				}
-				bitmain_update_temps(bitmain, info, &rxstatusdata);
-			}
-
-			found = true;
-			spare = packethead.length + 4 + i;
-			if (spare > *offset) {
-				applog(LOG_ERR, "%s%d: %s() spare(%d) > offset(%d)",
-						bitmain->drv->name, bitmain->device_id,
-						__func__, spare, *offset);
-				spare = *offset;
-			}
-			break;
-		} else if (buf[i] == 0xa2) {
-			struct bitmain_rxnonce_data rxnoncedata;
-			int nonce_num = 0;
-			applog(LOG_DEBUG, "%s%d: %s() RxNonce Data",
-					  bitmain->drv->name, bitmain->device_id,
-					  __func__);
-			if (*offset < 4)
-				return;
-			memcpy(&packethead, buf+i, sizeof(struct bitmain_packet_head));
-			packethead.length = htole16(packethead.length);
-			if (packethead.length > 1030) {
-				applog(LOG_ERR, "%s%d: %s() RxNonce Data datalen=%d error",
-						bitmain->drv->name, bitmain->device_id,
-						__func__, packethead.length+4);
-				continue;
-			}
-			if (*offset < packethead.length + 4)
-				return;
-			if (bitmain_parse_rxnonce(buf+i, packethead.length+4, &rxnoncedata, &nonce_num) != 0) {
-				applog(LOG_ERR, "%s%d: %s() RxNonce Data error len=%d",
-						bitmain->drv->name, bitmain->device_id,
-						__func__, packethead.length+4);
-			} else {
-				for (j = 0; j < nonce_num; j++) {
-					searches = 0;
-					mutex_lock(&info->qlock);
-					witem = info->work_list->head;
-					while (witem && DATAW(witem)->work) {
-						searches++;
-						if (DATAW(witem)->wid == rxnoncedata.nonces[j].work_id)
-							break;
-						witem = witem->next;
-					}
-					if (witem && DATAW(witem)->work) {
-						work = DATAW(witem)->work;
-						mutex_unlock(&info->qlock);
-						if (info->work_search == 0) {
-							info->min_search = searches;
-							info->max_search = searches;
-						} else {
-							if (info->min_search > searches)
-								info->min_search = searches;
-							if (info->max_search < searches)
-								info->max_search = searches;
-						}
-						info->work_search++;
-						info->tot_search += searches;
+								work->id, ob_hex);
+						free(ob_hex);
 
-						applog(LOG_DEBUG, "%s%d: %s() RxNonce Data find "
-								  "work(%"PRIu32"-%"PRIu32")(%08x)",
-								  bitmain->drv->name, bitmain->device_id,
-								  __func__, work->id,
-								  rxnoncedata.nonces[j].work_id,
-								  rxnoncedata.nonces[j].nonce);
+						ob_hex = bin2hex(work->data+64, 12);
+						applog(LOG_ERR, "%s%d: work %d data2: %s",i
+								bitmain->drv->name, bitmain->device_id,
+								work->id, ob_hex);
+						free(ob_hex);*/
 
+						//info->matching_work[work->subid]++;
 						applog(LOG_DEBUG, "%s%d: %s() nonce = %08x",
 								  bitmain->drv->name, bitmain->device_id,
 								  __func__, rxnoncedata.nonces[j].nonce);
-						if (isdupnonce(bitmain, work, rxnoncedata.nonces[j].nonce)) {
-							// ignore it
-						} else {
-							if (submit_nonce(thr, work, rxnoncedata.nonces[j].nonce)) {
-								applog(LOG_DEBUG, "%s%d: %s() RxNonce Data ok",
-										  bitmain->drv->name,
-										  bitmain->device_id,
-										  __func__);
-								mutex_lock(&info->qlock);
-								info->nonces += work->device_diff;
-								mutex_unlock(&info->qlock);
-							} else {
-								applog(LOG_ERR, "%s%d: %s() RxNonce Data "
-										"error work(%"PRIu32")",
-										bitmain->drv->name,
-										bitmain->device_id,
-										__func__,
-										rxnoncedata.nonces[j].work_id);
-							}
-						}
+						if (submit_nonce(thr, work, rxnoncedata.nonces[j].nonce)) {
+					 		applog(LOG_DEBUG, "%s%d: %s() RxNonce Data ok",
+									  bitmain->drv->name,
+									  bitmain->device_id,
+									  __func__);
+					 		mutex_lock(&info->qlock);
+					 		info->nonces++;
+							info->auto_nonces++;
+							mutex_unlock(&info->qlock);
+					 	} else {
+					 		//bitmain_inc_nvw(info, thr);
+					 		applog(LOG_ERR, "%s%d: %s() RxNonce Data "
+									"error work(%"PRIu32")",
+									bitmain->drv->name,
+									bitmain->device_id,
+									__func__,
+									rxnoncedata.nonces[j].work_id);
+					 	}
 					} else {
-						mutex_unlock(&info->qlock);
 						if (info->failed_search == 0) {
 							info->min_failed = searches;
 							info->max_failed = searches;
@@ -1586,6 +1020,7 @@ static void bitmain_parse_results(struct
 						info->failed_search++;
 						info->tot_failed += searches;
 
+						//bitmain_inc_nvw(info, thr);
 						applog(LOG_ERR, "%s%d: %s() Work not found for id (%"PRIu32")",
 								bitmain->drv->name, bitmain->device_id,
 								__func__, rxnoncedata.nonces[j].work_id);
@@ -1593,24 +1028,21 @@ static void bitmain_parse_results(struct
 				}
 				mutex_lock(&info->qlock);
 				info->fifo_space = rxnoncedata.fifo_space;
-				mutex_unlock(&info->qlock);
 				applog(LOG_DEBUG, "%s%d: %s() RxNonce Data fifo space=%d",
 						  bitmain->drv->name, bitmain->device_id,
-						  __func__, rxnoncedata.fifo_space);
-
-				if (nonce_num < BITMAIN_MAX_NONCE_NUM)
-					cgsleep_ms(5);
+						  __func__, info->fifo_space);
+				mutex_unlock(&info->qlock);
 			}
 
-			found = true;
-			spare = packethead.length + 4 + i;
-			if (spare > *offset) {
-				applog(LOG_ERR, "%s%d: %s() RxNonce Data space(%d) > offset(%d)",
-						bitmain->drv->name, bitmain->device_id, __func__,
+ 			found = true;
+ 			spare = buf[i+1] + 2 + i;
+ 			if (spare > *offset) {
+ 				applog(LOG_ERR, "%s%d: %s() RxNonce Data space(%d) > offset(%d)",
+						bitmain->drv->name, bitmain->device_id, __func__, 
 						spare, *offset);
-				spare = *offset;
-			}
-			break;
+ 				spare = *offset;
+ 			}
+ 			break;
 		} else {
 			applog(LOG_ERR, "%s%d: %s() data type error=%02x",
 					bitmain->drv->name, bitmain->device_id,
@@ -1628,7 +1060,6 @@ static void bitmain_parse_results(struct
 
 	*offset -= spare;
 	memmove(buf, buf + spare, *offset);
-#endif
 }
 
 static void bitmain_running_reset(struct bitmain_info *info)
@@ -1678,10 +1109,8 @@ static void *bitmain_get_results(void *u
 			offset = 0;
 		}
 
-#ifdef USE_ANT_S1
 		// 2ms shouldn't be too much
 		cgsleep_ms(2);
-#endif
 
 		applog(LOG_DEBUG, "%s%d: %s() read",
 				  bitmain->drv->name, bitmain->device_id, __func__);
@@ -1691,13 +1120,9 @@ static void *bitmain_get_results(void *u
 
 		if (ret < 1) {
 			errorcount++;
-#ifdef USE_ANT_S1
 			if (errorcount > 100) {
-#else
-			if (errorcount > 3) {
-#endif
-//				applog(LOG_ERR, "%s%d: read errorcount>100 ret=%d",
-//						bitmain->drv->name, bitmain->device_id, ret);
+				applog(LOG_ERR, "%s%d: read errorcount>100 ret=%d",
+						bitmain->drv->name, bitmain->device_id, ret);
 				cgsleep_ms(20);
 				errorcount = 0;
 			}
@@ -1763,23 +1188,7 @@ static int bitmain_initialize(struct cgp
 	struct bitmain_rxstatus_data rxstatusdata;
 	int i = 0, j = 0, m = 0, statusok = 0;
 	uint32_t checkbit = 0x00000000;
-#ifdef USE_ANT_S1
 	int eft = 0;
-#else
-	int r = 0;
-	int hwerror_eft = 0;
-	int beeper_ctrl = 1;
-	int tempover_ctrl = 1;
-	struct bitmain_packet_head packethead;
-	int asicnum = 0;
-
-	int mathtest = (int)floor(log2(42));
-	if (mathtest != 5) {
-		applog(LOG_ERR, "%s%d: %s() floating point math library is deficient",
-				bitmain->drv->name, bitmain->device_id, __func__);
-		return -1;
-	}
-#endif
 
 	/* Send reset, then check for result */
 	if (!bitmain) {
@@ -1827,7 +1236,6 @@ static int bitmain_initialize(struct cgp
 									  bitmain->device_id);
 							hexdump(data, readlen);
 						}
-#ifdef USE_ANT_S1
 						if (data[i+1] > 124) {
 							applog(LOG_ERR, "%s%d: %s() rxstatus datalen=%d error",
 									bitmain->drv->name, bitmain->device_id,
@@ -1885,115 +1293,6 @@ static int bitmain_initialize(struct cgp
 									info->chain_asic_status[i],
 									info->chain_asic_status_t[i]);
 						}
-#else // S2
-						memcpy(&packethead, data+i, sizeof(struct bitmain_packet_head));
-						packethead.length = htole16(packethead.length);
-
-						if (packethead.length > 1130) {
-							applog(LOG_ERR, "%s%d: %s() rxstatus datalen=%d error",
-									bitmain->drv->name, bitmain->device_id,
-									__func__, packethead.length+4);
-							continue;
-						}
-						if (readlen-i < packethead.length+4) {
-							applog(LOG_ERR, "%s%d: %s() rxstatus datalen=%d<%d low",
-									bitmain->drv->name, bitmain->device_id,
-									__func__, readlen-i, packethead.length+4);
-							continue;
-						}
-						if (bitmain_parse_rxstatus(data+i, packethead.length+4, &rxstatusdata) != 0) {
-							applog(LOG_ERR, "%s%d: %s() parse_rxstatus error",
-									bitmain->drv->name, bitmain->device_id,
-									__func__);
-							continue;
-						}
-						info->chain_num = rxstatusdata.chain_num;
-						info->fifo_space = rxstatusdata.fifo_space;
-						info->hw_version[0] = rxstatusdata.hw_version[0];
-						info->hw_version[1] = rxstatusdata.hw_version[1];
-						info->hw_version[2] = rxstatusdata.hw_version[2];
-						info->hw_version[3] = rxstatusdata.hw_version[3];
-						info->nonce_error = 0;
-						info->last_nonce_error = 0;
-						applog(LOG_ERR, "%s%d: %s() parse_rxstatus "
-								"version(%d) chain_num(%d) fifo_space(%d) "
-								"hwv1(%d) hwv2(%d) hwv3(%d) hwv4(%d) "
-								"nonce_error(%d) freq=%d",
-								bitmain->drv->name, bitmain->device_id,
-								__func__, rxstatusdata.version,
-								info->chain_num, info->fifo_space,
-								info->hw_version[0], info->hw_version[1],
-								info->hw_version[2], info->hw_version[3],
-								rxstatusdata.nonce_error,
-								info->frequency);
-
-						memcpy(info->chain_asic_exist,
-							rxstatusdata.chain_asic_exist,
-							BITMAIN_MAX_CHAIN_NUM*32);
-						memcpy(info->chain_asic_status,
-							rxstatusdata.chain_asic_status,
-							BITMAIN_MAX_CHAIN_NUM*32);
-						for (i = 0; i < rxstatusdata.chain_num; i++) {
-							info->chain_asic_num[i] = rxstatusdata.chain_asic_num[i];
-							memset(info->chain_asic_status_t[i], 0, 320);
-							j = 0;
-							if (info->chain_asic_num[i] <= 0)
-								asicnum = 0;
-							else {
-								if (info->chain_asic_num[i] % 32 == 0)
-									asicnum = info->chain_asic_num[i] / 32;
-								else
-									asicnum = info->chain_asic_num[i] / 32 + 1;
-							}
-							if (asicnum > 0) {
-								for (m = asicnum-1; m >= 0; m--) {
-									for (r = 0; r < 32; r++) {
-										if (r%8 == 0 && r != 0) {
-											info->chain_asic_status_t[i][j] = ' ';
-											j++;
-										}
-										checkbit = num2bit(r);
-										if (rxstatusdata.chain_asic_exist[i*8+m] & checkbit) {
-											if (rxstatusdata.chain_asic_status[i*8+m] & checkbit)
-												info->chain_asic_status_t[i][j] = 'o';
-											else
-												info->chain_asic_status_t[i][j] = 'x';
-										} else
-											info->chain_asic_status_t[i][j] = '-';
-										j++;
-									}
-									info->chain_asic_status_t[i][j] = ' ';
-									j++;
-								}
-							}
-							applog(LOG_DEBUG, "%s%d: %s() chain(%d) asic_num=%d "
-									  "asic_exist=%08x%08x%08x%08x%08x%08x%08x%08x "
-									  "asic_status=%08x%08x%08x%08x%08x%08x%08x%08x",
-									  bitmain->drv->name, bitmain->device_id,
-									  __func__, i, info->chain_asic_num[i],
-									  info->chain_asic_exist[i*8+0],
-									  info->chain_asic_exist[i*8+1],
-									  info->chain_asic_exist[i*8+2],
-									  info->chain_asic_exist[i*8+3],
-									  info->chain_asic_exist[i*8+4],
-									  info->chain_asic_exist[i*8+5],
-									  info->chain_asic_exist[i*8+6],
-									  info->chain_asic_exist[i*8+7],
-									  info->chain_asic_status[i*8+0],
-									  info->chain_asic_status[i*8+1],
-									  info->chain_asic_status[i*8+2],
-									  info->chain_asic_status[i*8+3],
-									  info->chain_asic_status[i*8+4],
-									  info->chain_asic_status[i*8+5],
-									  info->chain_asic_status[i*8+6],
-									  info->chain_asic_status[i*8+7]);
-							applog(LOG_ERR, "%s%d: %s() chain(%d) "
-									"asic_num=%d asic_status=%s",
-									bitmain->drv->name, bitmain->device_id,
-									__func__, i, info->chain_asic_num[i],
-									info->chain_asic_status_t[i]);
-						}
-#endif
 						bitmain_update_temps(bitmain, info, &rxstatusdata);
 						statusok = 1;
 						break;
@@ -2018,7 +1317,6 @@ static int bitmain_initialize(struct cgp
 	if (statusok) {
 		applog(LOG_ERR, "%s%d: %s() set_txconfig",
 				bitmain->drv->name, bitmain->device_id, __func__);
-#ifdef USE_ANT_S1
 		if (opt_bitmain_hwerror)
 			eft = 1;
 		else
@@ -2030,28 +1328,6 @@ static int bitmain_initialize(struct cgp
 						BITMAIN_DEFAULT_FAN_MAX_PWM, info->timeout,
 						info->frequency, BITMAIN_DEFAULT_VOLTAGE,
 						0, 0, 0x04, info->reg_data);
-#else // S2
-		if (opt_bitmain_hwerror)
-			hwerror_eft = 1;
-		else
-			hwerror_eft = 0;
-		if (opt_bitmain_beeper)
-			beeper_ctrl = 1;
-		else
-			beeper_ctrl = 0;
-		if (opt_bitmain_tempoverctrl)
-			tempover_ctrl = 1;
-		else
-			tempover_ctrl = 0;
-
-		sendlen = bitmain_set_txconfig((struct bitmain_txconfig_token *)sendbuf,
-						1, 1, 1, 1, 1, 0, 1, hwerror_eft,
-						beeper_ctrl, tempover_ctrl,
-						info->chain_num, info->asic_num,
-						BITMAIN_DEFAULT_FAN_MAX_PWM, info->timeout,
-						info->frequency, BITMAIN_DEFAULT_VOLTAGE,
-						0, 0, 0x04, info->reg_data);
-#endif
 		if (sendlen <= 0) {
 			applog(LOG_ERR, "%s%d: %s() set_txconfig error(%d)",
 					bitmain->drv->name, bitmain->device_id, __func__, sendlen);
@@ -2074,32 +1350,11 @@ static int bitmain_initialize(struct cgp
 	return 0;
 }
 
-static void ant_info(struct bitmain_info *info, int baud, int chain_num, int asic_num, int timeout, int frequency, uint8_t *reg_data)
-{
-	info->baud = baud;
-	info->chain_num = chain_num;
-	info->asic_num = asic_num;
-	info->timeout = timeout;
-	info->frequency = frequency;
-	memcpy(info->reg_data, reg_data, 4);
-
-	info->voltage = BITMAIN_DEFAULT_VOLTAGE;
-
-	info->fan_pwm = BITMAIN_DEFAULT_FAN_MIN_PWM;
-	info->temp_max = 0;
-	/* This is for check the temp/fan every 3~4s */
-	info->temp_history_count = (4 / (float)((float)info->timeout * ((float)1.67/0x32))) + 1;
-	if (info->temp_history_count <= 0)
-		info->temp_history_count = 1;
-
-	info->temp_history_index = 0;
-	info->temp_sum = 0;
-}
-
 static struct cgpu_info *bitmain_detect_one(libusb_device *dev, struct usb_find_devices *found)
 {
 	int baud, chain_num, asic_num, timeout, frequency = 0;
 	uint8_t reg_data[4] = {0};
+	int this_option_offset = ++option_offset;
 	struct bitmain_info *info;
 	struct cgpu_info *bitmain;
 	bool configured;
@@ -2108,7 +1363,7 @@ static struct cgpu_info *bitmain_detect_
 	if (opt_bitmain_options == NULL)
 		return NULL;
 
-	bitmain = usb_alloc_cgpu(&ANTDRV, BITMAIN_MINER_THREADS);
+	bitmain = usb_alloc_cgpu(&ants1_drv, BITMAIN_MINER_THREADS);
 
 	baud = BITMAIN_IO_SPEED;
 	chain_num = BITMAIN_DEFAULT_CHAIN_NUM;
@@ -2119,7 +1374,7 @@ static struct cgpu_info *bitmain_detect_
 	if (!usb_init(bitmain, dev, found))
 		goto shin;
 
-	configured = get_options(++option_offset, &baud, &chain_num,
+	configured = get_options(this_option_offset, &baud, &chain_num,
 				 &asic_num, &timeout, &frequency, reg_data);
 
 	/* Even though this is an FTDI type chip, we want to do the parsing
@@ -2131,18 +1386,38 @@ static struct cgpu_info *bitmain_detect_
 		quit(1, "Failed to calloc bitmain_info data");
 	info = bitmain->device_data;
 
-	if (configured)
-		ant_info(info, baud, chain_num, asic_num, timeout, frequency, reg_data);
-	else
-		ant_info(info, BITMAIN_IO_SPEED, BITMAIN_DEFAULT_CHAIN_NUM,
-			  BITMAIN_DEFAULT_ASIC_NUM, BITMAIN_DEFAULT_TIMEOUT,
-			  BITMAIN_DEFAULT_FREQUENCY, reg_data);
+	if (configured) {
+		info->baud = baud;
+		info->chain_num = chain_num;
+		info->asic_num = asic_num;
+		info->timeout = timeout;
+		info->frequency = frequency;
+		memcpy(info->reg_data, reg_data, 4);
+	} else {
+		info->baud = BITMAIN_IO_SPEED;
+		info->chain_num = BITMAIN_DEFAULT_CHAIN_NUM;
+		info->asic_num = BITMAIN_DEFAULT_ASIC_NUM;
+		info->timeout = BITMAIN_DEFAULT_TIMEOUT;
+		info->frequency = BITMAIN_DEFAULT_FREQUENCY;
+		memset(info->reg_data, 0, 4);
+	}
+	info->voltage = BITMAIN_DEFAULT_VOLTAGE;
+
+	info->fan_pwm = BITMAIN_DEFAULT_FAN_MIN_PWM;
+	info->temp_max = 0;
+	/* This is for check the temp/fan every 3~4s */
+	info->temp_history_count = (4 / (float)((float)info->timeout * ((float)1.67/0x32))) + 1;
+	if (info->temp_history_count <= 0)
+		info->temp_history_count = 1;
+
+	info->temp_history_index = 0;
+	info->temp_sum = 0;
 
 	if (!add_cgpu(bitmain))
 		goto unshin;
 
 	applog(LOG_ERR, "%s: detected %s%d",
-			ANTDRV.dname, bitmain->drv->name, bitmain->device_id);
+			ants1_drv.dname, bitmain->drv->name, bitmain->device_id);
 	ret = bitmain_initialize(bitmain);
 	if (ret && !configured)
 		goto unshin;
@@ -2153,9 +1428,6 @@ static struct cgpu_info *bitmain_detect_
 
 	info->work_list = k_new_list("Work", sizeof(WITEM), ALLOC_WITEMS, LIMIT_WITEMS, true);
 	info->work_ready = k_new_store(info->work_list);
-#ifdef USE_ANT_S2
-	info->wbuild = k_new_store(info->work_list);
-#endif
 
 	applog(LOG_DEBUG, "%s%d: detected %s "
 			  "chain_num=%d asic_num=%d timeout=%d frequency=%d",
@@ -2179,122 +1451,10 @@ shin:
 	return NULL;
 }
 
-#ifdef USE_ANT_S2
-static void ser_detect()
-{
-	int baud, chain_num, asic_num, timeout, frequency = 0;
-	uint8_t reg_data[4] = {0};
-	struct cgpu_info *bitmain;
-	struct bitmain_info *info;
-	bool configured;
-	int ret;
-
-	applog(LOG_WARNING, "%s: checking for %s", ANTDRV.dname, opt_bitmain_dev);
-
-	if (!opt_bitmain_options || !(*opt_bitmain_options)) {
-		applog(LOG_ERR, "%s: no bitmain-options specified", ANTDRV.dname);
-		return;
-	}
-
-	bitmain = calloc(1, sizeof(*bitmain));
-	if (unlikely(!bitmain))
-		quithere(1, "Failed to calloc bitmain");
-
-	bitmain->drv = &ANTDRV;
-	bitmain->deven = DEV_ENABLED;
-	bitmain->threads = 1;
-	bitmain->usbinfo.nodev = true;
-
-	configured = get_options(++option_offset, &baud, &chain_num,
-				  &asic_num, &timeout, &frequency, reg_data);
-
-	info = calloc(1, sizeof(*info));
-	if (unlikely(!info))
-		quit(1, "Failed to calloc bitmain_info");
-	bitmain->device_data = (void *)info;
-
-	info->device_fd = open(opt_bitmain_dev, O_RDWR|O_EXCL|O_NONBLOCK);
-	if (info->device_fd == -1) {
-		applog(LOG_DEBUG, "%s open %s error %d",
-				  bitmain->drv->dname, opt_bitmain_dev, errno);
-		goto giveup;
-	}
-
-	bitmain->device_path = strdup(opt_bitmain_dev);
-	bitmain->usbinfo.nodev = false;
-
-	if (configured)
-		ant_info(info, baud, chain_num, asic_num, timeout, frequency, reg_data);
-	else
-		ant_info(info, BITMAIN_IO_SPEED, BITMAIN_DEFAULT_CHAIN_NUM,
-			  BITMAIN_DEFAULT_ASIC_NUM, BITMAIN_DEFAULT_TIMEOUT,
-			  BITMAIN_DEFAULT_FREQUENCY, reg_data);
-
-	if (!add_cgpu(bitmain))
-		goto cleen;
-
-	ret = bitmain_initialize(bitmain);
-	if (ret && !configured)
-		goto cleen;
-
-	info->errorcount = 0;
-
-	info->work_list = k_new_list("Work", sizeof(WITEM), ALLOC_WITEMS, LIMIT_WITEMS, true);
-	info->work_ready = k_new_store(info->work_list);
-	info->wbuild = k_new_store(info->work_list);
-
-	applog(LOG_DEBUG, "%s%d: detected %s "
-			  "chain_num=%d asic_num=%d timeout=%d frequency=%d",
-			  bitmain->drv->name, bitmain->device_id, bitmain->device_path,
-			  info->chain_num, info->asic_num, info->timeout,
-			  info->frequency);
-
-	dupalloc(bitmain, 10);
-
-	return;
-
-cleen:
-	if (info->device_fd != -1)
-		close(info->device_fd);
-	free(bitmain->device_path);
-
-giveup:
-	free(info);
-	free(bitmain);
-}
-#endif
-
-#ifdef USE_ANT_S1
 static void ants1_detect(bool __maybe_unused hotplug)
 {
-	is_usb = true;
-	usb_detect(&ANTDRV, bitmain_detect_one);
+	usb_detect(&ants1_drv, bitmain_detect_one);
 }
-#endif
-
-
-#ifdef USE_ANT_S2
-static bool first_ant = true;
-
-static void ants2_detect(bool __maybe_unused hotplug)
-{
-	// Only ever do this once
-	if (!first_ant)
-		return;
-
-	first_ant = false;
-
-	if (opt_bitmain_dev && *opt_bitmain_dev)
-		is_usb = false;
-	else
-		is_usb = true;
-
-	if (is_usb)
-		usb_detect(&ANTDRV, bitmain_detect_one);
-	else
-		ser_detect();
-}
-#endif
 
 static void do_bitmain_close(struct thr_info *thr)
 {
@@ -2329,6 +1489,7 @@ static void get_bitmain_statline_before(
 static bool bitmain_fill(struct cgpu_info *bitmain)
 {
 	struct bitmain_info *info = bitmain->device_data;
+	int subid;
 	struct work *work, *usework;
 	bool ret = true;
 	int sendret = 0, sentcount = 0, neednum = 0, queuednum = 0, sendnum = 0, sendlen = 0;
@@ -2340,7 +1501,6 @@ static bool bitmain_fill(struct cgpu_inf
 	int timediff = 0;
 	K_ITEM *witem;
 
-#ifdef USE_ANT_S1
 	/*
 	 * Overheat just means delay the next work
 	 * since the temperature reply is only found with a work reply,
@@ -2382,7 +1542,6 @@ static bool bitmain_fill(struct cgpu_inf
 		}
 
 	}
-#endif
 
 	applog(LOG_DEBUG, "%s%d: %s() start",
 			  bitmain->drv->name, bitmain->device_id,
@@ -2402,11 +1561,7 @@ static bool bitmain_fill(struct cgpu_inf
 		ret = false;
 
 	while (info->fifo_space > 0) {
-#ifdef USE_ANT_S1
 		neednum = info->fifo_space<8?info->fifo_space:8;
-#else
-		neednum = info->fifo_space<BITMAIN_MAX_WORK_NUM?info->fifo_space:BITMAIN_MAX_WORK_NUM;
-#endif
 		queuednum = info->queued;
 		applog(LOG_DEBUG, "%s%d: Work task queued(%d) fifo space(%d) needsend(%d)",
 				  bitmain->drv->name, bitmain->device_id,
@@ -2434,6 +1589,8 @@ static bool bitmain_fill(struct cgpu_inf
 						usework->devflag = true;
 					}
 
+					subid = info->queued++;
+					usework->subid = subid;
 					witem = k_unlink_tail(info->work_list);
 					if (DATAW(witem)->work) {
 						// Was it rolled?
@@ -2443,9 +1600,7 @@ static bool bitmain_fill(struct cgpu_inf
 							work_completed(bitmain, DATAW(witem)->work);
 					}
 					DATAW(witem)->work = usework;
-					DATAW(witem)->wid = ++info->last_wid;
-					info->queued++;
-					k_add_head(info->work_ready, witem);
+					k_add_tail(info->work_ready, witem);
 					queuednum++;
 					roll++;
 				}
@@ -2569,12 +1724,12 @@ static int64_t bitmain_scanhash(struct t
 
 	mutex_lock(&info->qlock);
 	hash_count = 0xffffffffull * (uint64_t)info->nonces;
-	info->results += info->nonces;
+	info->results += info->nonces + info->idle;
 	if (info->results > chain_num)
 		info->results = chain_num;
 	if (!info->reset)
 		info->results--;
-	info->nonces = 0;
+	info->nonces = info->idle = 0;
 	mutex_unlock(&info->qlock);
 
 	/* Check for nothing but consecutive bad results or consistently less
@@ -2600,13 +1755,12 @@ static void bitmain_flush_work(struct cg
 	struct bitmain_info *info = bitmain->device_data;
 	//int i = 0;
 
+	mutex_lock(&info->qlock);
 	applog(LOG_ERR, "%s%d: %s() queued=%d",
 			bitmain->drv->name, bitmain->device_id,
 			__func__, info->queued);
-	mutex_lock(&info->qlock);
 	/* Will overwrite any work queued */
 	info->queued = 0;
-	k_list_transfer_to_tail(info->work_ready, info->work_list);
 	//pthread_cond_signal(&info->qcond);
 	mutex_unlock(&info->qlock);
 }
@@ -2625,52 +1779,18 @@ static struct api_data *bitmain_api_stat
 	root = api_add_int(root, "timeout", &(info->timeout), false);
 	root = api_add_int(root, "frequency", &(info->frequency), false);
 	root = api_add_int(root, "voltage", &(info->voltage), false);
-#ifdef USE_ANT_S2
-	root = api_add_int(root, "hwv1", &(info->hw_version[0]), false);
-	root = api_add_int(root, "hwv2", &(info->hw_version[1]), false);
-	root = api_add_int(root, "hwv3", &(info->hw_version[2]), false);
-	root = api_add_int(root, "hwv4", &(info->hw_version[3]), false);
-#endif
 
 	root = api_add_int(root, "fan_num", &(info->fan_num), false);
 	root = api_add_int(root, "fan1", &(info->fan[0]), false);
 	root = api_add_int(root, "fan2", &(info->fan[1]), false);
 	root = api_add_int(root, "fan3", &(info->fan[2]), false);
 	root = api_add_int(root, "fan4", &(info->fan[3]), false);
-#ifdef USE_ANT_S2
-	root = api_add_int(root, "fan5", &(info->fan[4]), false);
-	root = api_add_int(root, "fan6", &(info->fan[5]), false);
-	root = api_add_int(root, "fan7", &(info->fan[6]), false);
-	root = api_add_int(root, "fan8", &(info->fan[7]), false);
-	root = api_add_int(root, "fan9", &(info->fan[8]), false);
-	root = api_add_int(root, "fan10", &(info->fan[9]), false);
-	root = api_add_int(root, "fan11", &(info->fan[10]), false);
-	root = api_add_int(root, "fan12", &(info->fan[11]), false);
-	root = api_add_int(root, "fan13", &(info->fan[12]), false);
-	root = api_add_int(root, "fan14", &(info->fan[13]), false);
-	root = api_add_int(root, "fan15", &(info->fan[14]), false);
-	root = api_add_int(root, "fan16", &(info->fan[15]), false);
-#endif
 
 	root = api_add_int(root, "temp_num", &(info->temp_num), false);
 	root = api_add_int(root, "temp1", &(info->temp[0]), false);
 	root = api_add_int(root, "temp2", &(info->temp[1]), false);
 	root = api_add_int(root, "temp3", &(info->temp[2]), false);
 	root = api_add_int(root, "temp4", &(info->temp[3]), false);
-#ifdef USE_ANT_S2
-	root = api_add_int(root, "temp5", &(info->temp[4]), false);
-	root = api_add_int(root, "temp6", &(info->temp[5]), false);
-	root = api_add_int(root, "temp7", &(info->temp[6]), false);
-	root = api_add_int(root, "temp8", &(info->temp[7]), false);
-	root = api_add_int(root, "temp9", &(info->temp[8]), false);
-	root = api_add_int(root, "temp10", &(info->temp[9]), false);
-	root = api_add_int(root, "temp11", &(info->temp[10]), false);
-	root = api_add_int(root, "temp12", &(info->temp[11]), false);
-	root = api_add_int(root, "temp13", &(info->temp[12]), false);
-	root = api_add_int(root, "temp14", &(info->temp[13]), false);
-	root = api_add_int(root, "temp15", &(info->temp[14]), false);
-	root = api_add_int(root, "temp16", &(info->temp[15]), false);
-#endif
 	root = api_add_int(root, "temp_avg", &(info->temp_avg), false);
 	root = api_add_int(root, "temp_max", &(info->temp_max), false);
 	root = api_add_percent(root, "Device Hardware%", &hwp, true);
@@ -2687,39 +1807,16 @@ static struct api_data *bitmain_api_stat
 	root = api_add_int(root, "chain_acn2", &(info->chain_asic_num[1]), false);
 	root = api_add_int(root, "chain_acn3", &(info->chain_asic_num[2]), false);
 	root = api_add_int(root, "chain_acn4", &(info->chain_asic_num[3]), false);
-#ifdef USE_ANT_S2
-	root = api_add_int(root, "chain_acn5", &(info->chain_asic_num[4]), false);
-	root = api_add_int(root, "chain_acn6", &(info->chain_asic_num[5]), false);
-	root = api_add_int(root, "chain_acn7", &(info->chain_asic_num[6]), false);
-	root = api_add_int(root, "chain_acn8", &(info->chain_asic_num[7]), false);
-	root = api_add_int(root, "chain_acn9", &(info->chain_asic_num[8]), false);
-	root = api_add_int(root, "chain_acn10", &(info->chain_asic_num[9]), false);
-	root = api_add_int(root, "chain_acn11", &(info->chain_asic_num[10]), false);
-	root = api_add_int(root, "chain_acn12", &(info->chain_asic_num[11]), false);
-	root = api_add_int(root, "chain_acn13", &(info->chain_asic_num[12]), false);
-	root = api_add_int(root, "chain_acn14", &(info->chain_asic_num[13]), false);
-	root = api_add_int(root, "chain_acn15", &(info->chain_asic_num[14]), false);
-	root = api_add_int(root, "chain_acn16", &(info->chain_asic_num[15]), false);
-#endif
 
 	root = api_add_string(root, "chain_acs1", info->chain_asic_status_t[0], false);
 	root = api_add_string(root, "chain_acs2", info->chain_asic_status_t[1], false);
 	root = api_add_string(root, "chain_acs3", info->chain_asic_status_t[2], false);
 	root = api_add_string(root, "chain_acs4", info->chain_asic_status_t[3], false);
-#ifdef USE_ANT_S2
-	root = api_add_string(root, "chain_acs5", info->chain_asic_status_t[4], false);
-	root = api_add_string(root, "chain_acs6", info->chain_asic_status_t[5], false);
-	root = api_add_string(root, "chain_acs7", info->chain_asic_status_t[6], false);
-	root = api_add_string(root, "chain_acs8", info->chain_asic_status_t[7], false);
-	root = api_add_string(root, "chain_acs9", info->chain_asic_status_t[8], false);
-	root = api_add_string(root, "chain_acs10", info->chain_asic_status_t[9], false);
-	root = api_add_string(root, "chain_acs11", info->chain_asic_status_t[10], false);
-	root = api_add_string(root, "chain_acs12", info->chain_asic_status_t[11], false);
-	root = api_add_string(root, "chain_acs13", info->chain_asic_status_t[12], false);
-	root = api_add_string(root, "chain_acs14", info->chain_asic_status_t[13], false);
-	root = api_add_string(root, "chain_acs15", info->chain_asic_status_t[14], false);
-	root = api_add_string(root, "chain_acs16", info->chain_asic_status_t[15], false);
-#endif
+
+	//root = api_add_int(root, "chain_acs1", &(info->chain_asic_status[0]), false);
+	//root = api_add_int(root, "chain_acs2", &(info->chain_asic_status[1]), false);
+	//root = api_add_int(root, "chain_acs3", &(info->chain_asic_status[2]), false);
+	//root = api_add_int(root, "chain_acs4", &(info->chain_asic_status[3]), false);
 
 	root = api_add_int(root, "work_list_total", &(info->work_list->total), true);
 	root = api_add_int(root, "work_list_count", &(info->work_list->count), true);
@@ -2738,7 +1835,6 @@ static struct api_data *bitmain_api_stat
 	root = api_add_avg(root, "avg_failed", &avg, true);
 
 	root = api_add_int(root, "temp_hi", &(info->temp_hi), false);
-#ifdef USE_ANT_S1
 	root = api_add_bool(root, "overheat", &(info->overheat), true);
 	root = api_add_int(root, "overheat_temp", &(info->overheat_temp), true);
 	root = api_add_uint32(root, "overheat_count", &(info->overheat_count), true);
@@ -2747,12 +1843,7 @@ static struct api_data *bitmain_api_stat
 	root = api_add_uint32(root, "overheat_slept", &(info->overheat_slept), true);
 	root = api_add_uint64(root, "overheat_total_sleep", &(info->overheat_total_sleep), true);
 	root = api_add_uint32(root, "overheat_recovers", &(info->overheat_recovers), true);
-#endif
 
-#ifdef USE_ANT_S2
-	root = api_add_bool(root, "opt_bitmain_beeper", &opt_bitmain_beeper, false);
-	root = api_add_bool(root, "opt_bitmain_tempoverctrl", &opt_bitmain_tempoverctrl, false);
-#endif
 	root = api_add_int(root, "opt_bitmain_temp", &opt_bitmain_temp, false);
 	root = api_add_int(root, "opt_bitmain_overheat", &opt_bitmain_overheat, false);
 	root = api_add_int(root, "opt_bitmain_fan_min", &opt_bitmain_fan_min, false);
@@ -2808,9 +1899,8 @@ char *set_bitmain_freq(char *arg)
 
 	return NULL;
 }
-#endif // LINUX
+#endif
 
-#ifdef USE_ANT_S1
 struct device_drv ants1_drv = {
 	.drv_id = DRIVER_ants1,
 	.dname = "BitmainAntS1",
@@ -2828,24 +1918,3 @@ struct device_drv ants1_drv = {
 	.thread_shutdown = bitmain_shutdown,
 #endif
 };
-#endif
-
-#ifdef USE_ANT_S2
-struct device_drv ants2_drv = {
-	.drv_id = DRIVER_ants2,
-	.dname = "BitmainAntS2",
-	.name = "AS2",
-	.drv_detect = ants2_detect,
-#ifdef LINUX
-	.thread_prepare = bitmain_prepare,
-	.hash_work = hash_queued_work,
-	.queue_full = bitmain_fill,
-	.scanwork = bitmain_scanhash,
-	.flush_work = bitmain_flush_work,
-	.get_api_stats = bitmain_api_stats,
-	.get_statline_before = get_bitmain_statline_before,
-	.reinit_device = bitmain_init,
-	.thread_shutdown = bitmain_shutdown,
-#endif
-};
-#endif
--- a/driver-bitmain.h	2014-07-29 02:22:06.185735192 +0000
+++ b/driver-bitmain.h	2014-07-29 02:22:16.625735146 +0000
@@ -12,7 +12,7 @@
 #ifndef BITMAIN_H
 #define BITMAIN_H
 
-#if defined(USE_ANT_S1) || defined(USE_ANT_S2)
+#ifdef USE_ANT_S1
 
 #include "util.h"
 #include "klist.h"
@@ -40,7 +40,7 @@
 
 #define BITMAIN_TEMP_TARGET 50
 #define BITMAIN_TEMP_HYSTERESIS 3
-#define BITMAIN_TEMP_OVERHEAT 75
+#define BITMAIN_TEMP_OVERHEAT 60
 
 #define BITMAIN_DEFAULT_TIMEOUT 0x2D
 #define BITMAIN_MIN_FREQUENCY 10
@@ -54,11 +54,7 @@
 
 #define BITMAIN_AUTO_CYCLE 1024
 
-#ifdef USE_ANT_S1
 #define BITMAIN_FTDI_READSIZE 510
-#else // S2
-#define BITMAIN_FTDI_READSIZE 2048
-#endif
 #define BITMAIN_USB_PACKETSIZE 512
 #define BITMAIN_SENDBUF_SIZE 8192
 #define BITMAIN_READBUF_SIZE 8192
@@ -66,52 +62,25 @@
 #define BITMAIN_READ_TIMEOUT 18 /* Enough to only half fill the buffer */
 #define BITMAIN_LATENCY 1
 
-#ifdef USE_ANT_S1
 #define BITMAIN_MAX_WORK_NUM       8
 #define BITMAIN_MAX_WORK_QUEUE_NUM 64
 #define BITMAIN_MAX_DEAL_QUEUE_NUM 1
 #define BITMAIN_MAX_NONCE_NUM      8
 #define BITMAIN_MAX_CHAIN_NUM      8
-#else // S2
-#define BITMAIN_MAX_WORK_NUM       64
-#define BITMAIN_MAX_WORK_QUEUE_NUM 4096
-#define BITMAIN_MAX_DEAL_QUEUE_NUM 32
-#define BITMAIN_MAX_NONCE_NUM      128
-#define BITMAIN_MAX_CHAIN_NUM      16
-#endif
-
 #define BITMAIN_MAX_TEMP_NUM       32
 #define BITMAIN_MAX_FAN_NUM        32
 
-#ifdef USE_ANT_S1
 #define BITMAIN_SEND_STATUS_TIME   10 //s
 #define BITMAIN_SEND_FULL_SPACE    128
-#else // S2
-#define BITMAIN_SEND_STATUS_TIME   15 //s
-#define BITMAIN_SEND_FULL_SPACE    512
-#endif
 
 #define BITMAIN_OVERHEAT_SLEEP_MS_MAX 10000
 #define BITMAIN_OVERHEAT_SLEEP_MS_MIN 200
 #define BITMAIN_OVERHEAT_SLEEP_MS_DEF 600
 #define BITMAIN_OVERHEAT_SLEEP_MS_STEP 200
 
-#ifdef USE_ANT_S2
-struct bitmain_packet_head {
-	uint8_t token_type;
-	uint8_t version;
-	uint16_t length;
-} __attribute__((packed, aligned(4)));
-#endif
-
 struct bitmain_txconfig_token {
 	uint8_t token_type;
-#ifdef USE_ANT_S1
 	uint8_t length;
-#else // S2
-	uint8_t version;
-	uint16_t length;
-#endif
 	uint8_t reset                :1;
 	uint8_t fan_eft              :1;
 	uint8_t timeout_eft          :1;
@@ -120,14 +89,7 @@ struct bitmain_txconfig_token {
 	uint8_t chain_check_time_eft :1;
 	uint8_t chip_config_eft      :1;
 	uint8_t hw_error_eft         :1;
-#ifdef USE_ANT_S1
 	uint8_t reserved1;
-#else // S2
-	uint8_t beeper_ctrl          :1;
-	uint8_t temp_over_ctrl       :1;
-	uint8_t reserved1            :6;
-	uint8_t reserved[2];
-#endif
 
 	uint8_t chain_num;
 	uint8_t asic_num;
@@ -151,7 +113,6 @@ struct bitmain_txtask_work {
 } __attribute__((packed, aligned(4)));
 
 struct bitmain_txtask_token {
-#ifdef USE_ANT_S1
 	uint8_t token_type;
 	uint8_t reserved1;
 	uint16_t length;
@@ -160,21 +121,9 @@ struct bitmain_txtask_token {
 	uint8_t reserved3[3];
 	struct bitmain_txtask_work works[BITMAIN_MAX_WORK_NUM];
 	uint16_t crc;
-#else // S2
-	uint8_t token_type;
-	uint8_t version;
-	uint16_t length;
-	uint8_t new_block            :1;
-	uint8_t reserved1            :7;
-	uint8_t diff;
-	uint8_t reserved2[2];
-	struct bitmain_txtask_work works[BITMAIN_MAX_WORK_NUM];
-	uint16_t crc;
-#endif
 } __attribute__((packed, aligned(4)));
 
 struct bitmain_rxstatus_token {
-#ifdef USE_ANT_S1
 	uint8_t token_type;
 	uint8_t length;
 	uint8_t chip_status_eft      :1;
@@ -185,23 +134,9 @@ struct bitmain_rxstatus_token {
 	uint8_t chip_address;
 	uint8_t reg_address;
 	uint16_t crc;
-#else // S2
-	uint8_t token_type;
-	uint8_t version;
-	uint16_t length;
-	uint8_t chip_status_eft      :1;
-	uint8_t detect_get           :1;
-	uint8_t reserved1            :6;
-	uint8_t reserved2[3];
-
-	uint8_t chip_address;
-	uint8_t reg_address;
-	uint16_t crc;
-#endif
 } __attribute__((packed, aligned(4)));
 
 struct bitmain_rxstatus_data {
-#ifdef USE_ANT_S1
 	uint8_t data_type;
 	uint8_t length;
 	uint8_t chip_value_eft       :1;
@@ -219,28 +154,6 @@ struct bitmain_rxstatus_data {
 	uint8_t temp[BITMAIN_MAX_TEMP_NUM];
 	uint8_t fan[BITMAIN_MAX_FAN_NUM];
 	uint16_t crc;
-#else // S2
-	uint8_t data_type;
-	uint8_t version;
-	uint16_t length;
-	uint8_t chip_value_eft       :1;
-	uint8_t reserved1            :7;
-	uint8_t chain_num;
-	uint16_t fifo_space;
-	uint8_t hw_version[4];
-	uint8_t fan_num;
-	uint8_t temp_num;
-	uint16_t fan_exist;
-	uint32_t temp_exist;
-	uint32_t nonce_error;
-	uint32_t reg_value;
-	uint32_t chain_asic_exist[BITMAIN_MAX_CHAIN_NUM*8];
-	uint32_t chain_asic_status[BITMAIN_MAX_CHAIN_NUM*8];
-	uint8_t chain_asic_num[BITMAIN_MAX_CHAIN_NUM];
-	uint8_t temp[BITMAIN_MAX_TEMP_NUM];
-	uint8_t fan[BITMAIN_MAX_FAN_NUM];
-	uint16_t crc;
-#endif
 } __attribute__((packed, aligned(4)));
 
 struct bitmain_rxnonce_nonce {
@@ -249,45 +162,24 @@ struct bitmain_rxnonce_nonce {
 } __attribute__((packed, aligned(4)));
 
 struct bitmain_rxnonce_data {
-#ifdef USE_ANT_S1
 	uint8_t data_type;
 	uint8_t length;
 	uint8_t fifo_space;
 	uint8_t nonce_num;
 	struct bitmain_rxnonce_nonce nonces[BITMAIN_MAX_NONCE_NUM];
 	uint16_t crc;
-#else
-	uint8_t data_type;
-	uint8_t version;
-	uint16_t length;
-	uint16_t fifo_space;
-	uint16_t diff;
-	uint64_t total_nonce_num;
-	struct bitmain_rxnonce_nonce nonces[BITMAIN_MAX_NONCE_NUM];
-	uint16_t crc;
-#endif
 } __attribute__((packed, aligned(4)));
 
 struct bitmain_info {
 	int queued;
 	int results;
-#ifdef USE_ANT_S1
+
 	int baud;
 	int chain_num;
 	int asic_num;
 	int chain_asic_num[BITMAIN_MAX_CHAIN_NUM];
 	uint32_t chain_asic_status[BITMAIN_MAX_CHAIN_NUM];
 	char chain_asic_status_t[BITMAIN_MAX_CHAIN_NUM][40];
-#else // S2
-	int device_fd;
-	int baud;
-	int chain_num;
-	int asic_num;
-	int chain_asic_num[BITMAIN_MAX_CHAIN_NUM];
-	uint32_t chain_asic_exist[BITMAIN_MAX_CHAIN_NUM*8];
-	uint32_t chain_asic_status[BITMAIN_MAX_CHAIN_NUM*8];
-	char chain_asic_status_t[BITMAIN_MAX_CHAIN_NUM][320];
-#endif
 	int timeout;
 	int errorcount;
 	uint32_t nonce_error;
@@ -300,6 +192,7 @@ struct bitmain_info {
 	int temp[BITMAIN_MAX_TEMP_NUM];
 
 	int temp_max;
+	int temp_hi;
 	int temp_avg;
 	int temp_history_count;
 	int temp_history_index;
@@ -308,18 +201,12 @@ struct bitmain_info {
 
 	int frequency;
 	int voltage;
-	int temp_hi;
-#ifdef USE_ANT_S2
-	uint64_t total_nonce_num;
-	int diff;
-#endif
 
 	int no_matching_work;
 	//int matching_work[BITMAIN_DEFAULT_CHAIN_NUM];
 
 	struct thr_info *thr;
 	pthread_t read_thr;
-	pthread_t write_thr;
 	pthread_mutex_t lock;
 	pthread_mutex_t qlock;
 	pthread_cond_t qcond;
@@ -329,18 +216,15 @@ struct bitmain_info {
 	unsigned int last_work_block;
 	struct timeval last_status_time;
 	int send_full_space;
-#ifdef USE_ANT_S2
-	int hw_version[4];
-#endif
 
 	int auto_queued;
+	int auto_nonces;
 	int auto_hw;
 
 	int idle;
 	bool reset;
-	bool optimal;
-#ifdef USE_ANT_S1
 	bool overheat;
+	bool optimal;
 	int overheat_temp;
 	uint32_t overheat_count;
 	uint32_t overheat_sleep_ms;
@@ -348,15 +232,11 @@ struct bitmain_info {
 	uint32_t overheat_slept;
 	uint64_t overheat_total_sleep;
 	uint32_t overheat_recovers;
-#endif
 
 	// Work
 	K_LIST *work_list;
 	K_STORE *work_ready;
-#ifdef USE_ANT_S2
-	K_STORE *wbuild;
-#endif
-	uint32_t last_wid;
+
 	uint64_t work_search;
 	uint64_t tot_search;
 	uint64_t min_search;
@@ -371,30 +251,19 @@ struct bitmain_info {
 // Work
 typedef struct witem {
 	struct work *work;
-	uint32_t wid;
+	bool clone;
 } WITEM;
 
-#ifdef USE_ANT_S1
 #define ALLOC_WITEMS 1024
-#else
-#define ALLOC_WITEMS 32768
-#endif
 /*
  * The limit doesn't matter since we simply take the tail item
  * every time, optionally free it, and then put it on the head
  */
-#ifdef USE_ANT_S1
 #define LIMIT_WITEMS 1024
-#else
-#define LIMIT_WITEMS 32768
-#endif
 
 #define DATAW(_item) ((WITEM *)(_item->data))
 
 #define BITMAIN_READ_SIZE 12
-#ifdef USE_ANT_S2
-#define BITMAIN_ARRAY_SIZE 16384
-#endif
 
 #define BTM_GETS_ERROR -1
 #define BTM_GETS_OK 0
@@ -417,5 +286,5 @@ extern bool opt_bitmain_auto;
 extern char *set_bitmain_fan(char *arg);
 extern char *set_bitmain_freq(char *arg);
 
-#endif /* USE_ANT_S1 || USE_ANT_S2 */
+#endif /* USE_ANT_S1 */
 #endif	/* BITMAIN_H */
